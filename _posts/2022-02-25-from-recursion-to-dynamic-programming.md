---
layout: post
title: "从递归到动态规划"
subtitle: "算法原来如此简洁优雅"
date: 2022-02-25 18:00:00
author: "Echcz"
header-style: "text"
catalog: true
tags:
  - "算法"
---
{% raw %}
## 递归

所谓递归，就是函数或方法自己调用自己。其思想是把一个大型复杂问题层层转化为一个比原问题规模更小的同类型问题，问题被拆解成子问题后，递归调用继续进行，直到子问题无需进一步递归就可以解决的地步为止。

递归的两大要素为：

1. 基本情况：基本情况用于保证程序调用及时返回，保证了程序是可终止的。
2. 递推关系：是递归的最核心内容，其描述了问题是如何层层转化为更小的问题的。

为了加深理解，下面展示 “求第 n(n >= 1) 位斐波拉契数列值” 的递归算法（Python实现）：

``` python
def f(n):
  if n == 0:
    return 0
  if n == 1:
    return 1
  return f(n-1) + f(n-2)
```

可以看出程序非常简洁。其核心代码只有一行：`return f(n-1) + f(n-2)`。其实斐波拉契的数据描述就是 `F(n) = F(n-1) + F(n-2)`。这样的使用小问题来描述大问题的数学例子还有很多，比如乘阶的数学描述就是 `n! = (n-1)! * n`。用递归的形式解此类问题，是非常简洁与优雅的。

## 带备忘录的递归

如果你仔细查看上面的递归算法，会发现一个可优化的地方，就是 `f(x) (x < n-1)` 会被重复计算。比如计算 `f(5)` 时，需要计算 `f(4)` 与 `f(3)`, 在接下来计算 `f(4)` 时，就需要计算 `f(3)` 与 `f(2)`，可以看出，`f(3)` 被计算了两次。我们知道，不管你何时算 `f(3)`，其结果都是固定的。所以这重复计算是完全没有必要的。我们可不可以使用一个缓存，把已经计算的结果给缓存起来，下次再遇到的同样的问题，直接读取缓存，就像备忘录一样，这样就不用重复计算了。下面是算法（Python实现）：

``` python
def f(n):
  buf = [None] * (n+1)
  buf[0] = 0
  buf[1] = 1
  return g(n, buf)

def g(n, buf):
  r = buf[n]
  if r == None:
    r = g(n-1, buf) + g(n-2, buf)
    buf[n] = r
  return r
```

## 动态规划

观察上面带备忘录的递归算法，你可能会想如果能把 `r = g(n-1, buf) + g(n-2 buf)` 改为 `r = buf[n-1] + buf[n-2]` 就好了，这样的性能更高，并且可以避免递归。毕竟递归虽然优雅，但也是有代价的：如果递归过深，可能导致方法栈溢出。那我们为什么不能这么改呢，究其原因，在于对 `g(n, buf)` 的调用是倒着调用的，也就是先调用 `g(n, buf)`, 然后再调用 `g(n-1, buf)`，当调用 `g[n, buf]` 时， `buf[n-1]` 还没有被计算并缓存。那么我们顺着计算不就行了吗？先把小的问题解决完了，再解决大的问题。这就是动态规划了。下面算法（Python实现）：

``` python
def f(n):
  dp = [None] * (n+1)
  dp[0] = 0
  dp[1] = 1
  for i in range(2, n+1):
    dp[i] = dp[i-1] + dp[i-2]
  return dp[n]
```

可以看出，动态规划的解法依然非常简洁，只是我们把递推关系写在了一个 for 循环里面，以让其先解决小问题再解决大问题。

参考带备录的递归，我们可以总结出动态规则的三大要素：

1. 状态定义（对应“缓存”）：每个状态的决策，存放每个状态的变量。
2. 初始状态（对应“基本情况”）：初始的状态或者边界条件。
3. 状态转移方程（对应“递推关系”）：当前状态与上一个状态之间的关系。

## 总结

动态规则与递归是一脉相承的，都是基于一个思想：一个大型复杂问题层层转化为一个比原问题规模更小的同类型问题，只是它们的计算方向相反。
{% endraw %}
