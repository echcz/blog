---
layout: post
title: "IO模型"
subtitle: "从阻塞到非阻塞，从同步到异步"
date: 2020-10-27 10:30:00
author: "Echcz"
header-style: "text"
catalog: true
tags:
  - "IO"
---
{% raw %}
## 同步异步与阻塞非阻塞

在正式理解IO模型前，还是很有必要理解同步异步、阻塞非阻塞这两对概念的：

* 同步异步：指任务序列是否可靠。换名话说，一个任务的完成是否需要等待其依赖的任务执行完成，要成功都成功，要失败都失败。其表现形式是消息通知机制的时机与方向，即是由主任务调用其依赖的任务执行并等待其完成，还是其依赖的任务在完成之后通知主任务。
* 阻塞非阻塞：指当一个线程等待消息通知时，其状态是是阻塞(挂起)状态还是仍处理激活状态。

需要注意的同步与异步、阻塞与非阻塞这两对概念是相互独立的，不要将它们进行挂勾。这两对概念结合起来有4个情况，以小明下载文件举例如下：

* 同步阻塞：小明文件下载，等待下载完成后再关闭电脑。
* 同步非阻塞：小明提交下载任务后就去做别的事了，每过一段时间就查看下载任务是否完成，如果下载完成，就关闭电脑。
* 异步阻塞：小明下载文件并设置下载软件下载完成后自动关闭电脑。但在此期间，小明什么事都不干，等待电脑关机。
* 异步非阻塞：小明下载文件并设置下载软件下载完成后自动关闭电脑。然后，小明就干别的事去了。

## 5种IO模型

### 同步模型

#### 阻塞IO

当应用程序发起系统调用读取数据时，应用程序会阻塞，一直等待数据从内核复制到用户空间完成返回。其流程如下:

1. 应用程序发起系统调用，读取数据
2. 应用程序阻塞。内核等待并准备数据报
3. 将数据从内核复制到应用空间
4. 复制完成后，返回成功提示
5. 应用程序解除阻塞，处理数据报

#### 非阻塞IO

当应用程序发起系统调用读取数据时，如果数据报没有准备好，即刻返回错误提示；如果数据报已经准备好，则将数据从内核复制到用户空间，完成后返回成功。其流程如下:

1. 应用程序发系统调用，读取数据
2. 如果数据没有准备好，返回错误提示。如果数据已经准备好，进行下一步
3. 系统将数据从内核复制到应用空间
4. 复制完成后，返回成功提示
5. 应用程序解除阻塞，处理数据报

为了最终能拿到数据，应用程序需要不断的向系统轮询。

#### 多路复用IO

想象一下，在并发环境下，如果同时有很多请求要进行IO操作的场景。这时如果还是如上述简单地使用阻塞IO或非阻塞IO，就会导致系统创建大量的线程去进行IO操作。但线程的创建、销毁、切换都需要不少的开销，所以我们需要改进模型，尽量减少操作IO的线程。

多路复用IO就是解决上述问题而提出的模型，其流程如下：

1. 应用程序将一个或多个IO传递给选择器(selector)，阻塞在选择(select)操作上
2. 选择器轮询侦测这些IO是否准备就绪
3. 当有IO准备就绪时，选择器返回数据可读状态
4. 应用程序执行系统调用将数据从内核空间读入用户空间

由上可知，多路复用模型通过让一个选择器同时监测多个IO状态从而减少了操作IO线程的使用量。同时，我们也可以发现多路复用IO是建立在非阻塞IO的基础上的。

#### 信号驱动式IO

多路复用IO有个不好的地方是需要通过不断轮询才能知道哪个IO准备就绪。这种方式其实是挺低效的，因为大部分轮询请求其实都是无效的。信号驱动式IO就是对多路复用IO在这方面的改进。它通过与内核建立信号关联的方式，让内核在数据报准备好时通知选择器，从而避免由轮询带来的开销。

### 异步模型

#### 异步IO

尽量使用多路复用IO或信号驱动式IO后，高并发环境下的IO性能已有很大提高，但我们还是能发现改进空间：它们总是要发起两阶段的请求，第一次询问数据状态是否准备好，第二次将读取数据。如果将这两阶段请求合成一次，就可以进一步提升效率。异步IO模型实现了这种改进。其流程如下：

1. 应用程序发起系统调用，异步读取数据(然后应用程序可以干其他事情了)
2. 内核等待并准备好数据
3. 内核将数据从内核空间复制到用户空间
4. 内核通知应用程序执行数据处理

如上所述，异步IO只需要发送一次系统调用就可以让内核完成从数据等待与准备与数据读取的全部操作，之后再由内核通知应用程序执行数据处理。

## IO模型里面的阻塞非阻塞、同步异步

IO模型的阻塞非阻塞指在数据报还没有准备好时，应用程序需不需要阻塞以等待数据准备好。如果需要阻塞等待，就是阻塞IO。如果不需等待而即刻返回错误提示就是非阻塞IO。从这点看，多路复用IO，信号驱动式IO也都是非阻塞IO。

IO模型的同步异步指在数据报准备好后，是由应用程序主动发起系统调用读取数据，还是内核直接复制数据并在完成后通知应用程序执行数据处理。
{% endraw %}