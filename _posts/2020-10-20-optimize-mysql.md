---
layout: post
title: "MySQL性能优化技巧"
subtitle: "从三个方面提升你的MySQL性能"
date: 2020-10-20 10:00:00
author: "Echcz"
header-style: "text"
catalog: true
tags:
  - "MySQL"
  - "性能优化"
---
{% raw %}
## 前言

在互联网行业，查询数据库可以说是最常调用的行为之一了。SQL的执行性能直接影响了互联网程序的执行性能，对SQL的优化可以说是性能优化的重中之重。如今，MySQL成为了互联网行业最常用的数据库，所以我们接下来研究MySQL的性能优化技巧。*注: 以下内容主要参考《高性能MySQL》*

## Schema与数据类型优化

### 基本原则

#### 选择更小更简单的数据类型

更小的数据类型占用更少的磁盘、内存和CPU缓存；更简单的数据类型操作起来也通常需要更少的CPU周期。例如: 可以使用`TINYINT`来存储年龄，而不是使用`INT`；使用MySQL内建的时间类型(如：`DATETIME`)存储时间，而不是使用`VARCHAR`。

#### 尽量避免NULL

如果查询中包含可以`NULL`的列，对MySQL来说更难优化，因为可以`NULL`的列使得索引，索引统计和值比较都更为复杂。可为`NULL`的列会使用更多空间，在MySQL里也需要特殊处理。当可为`NULL`的列被索引时，每个索引记录需要一个额外的字节，在`MyISAM`里甚至可能导致固定大小的索引变成可变大小的索引。

不过通常把可以`NULL`的列改为`NOT NULL`带来的提升较小，调优时没有必要把这放在高的优先级中。但如果计划在列上建索引，就应该尽量避免此列可为`NULL`。

#### 避免太多的列

MySQL的存储引擎API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列。从行缓冲中将编码过的列转换成行数据结构的操作代价是非常高的，并且转换的代价依赖列的数量。

#### 避免太多的关联

关联查询是需要付出解析和优化查询的代价的。一个粗略的经验法则是：如果希望查询执行得快速且并发性好，单个查询最好在12个表以内在关联。

#### 保持关联列类型的一致性

尽量使用相同的数据类型存储相似或相关的值，尤其是在要关联的条件中使用列。这样能避免关联或比较里隐式的类型转化的开销与可能的很难发现的BUG。

### 类型说明与选择

#### 数字类型

MySQL中的数字类型大致有3类：整数、浮点数和高精度数字。

* MySQL提供了多种长度的整数类型，并且可以给整数类型设置UNSIGNED属性，可以根据自己的需要做出合适的选择。有一点需要注意的，给整数类型指定显示长度在性能上是没有意义的，并且也不推荐显示指定。
* 浮点数和高清度数字都可以表示小数。但浮点数是不精确的，只能做近似计算。高精度数字则能做到此精确计算，但因为CPU不直接支持高精度数字的计算，所以高精度数字的计算相比浮点数性能更低一些。我们需要根据自己的实际需要选择使用浮点数还是高精度数字。如果对计算精度要求很高(比如涉及到金融)，则需要使用高精度数字，如果没严格的要求，则可以使用浮点数。
* 对于数字范围与小数位数比较确定的情况，可以使用整数代替实数。在计算前后只需要将相应的数字乘以或除以相应的倍数即可。

#### 字符串类型

在MySQL中，最主要有两种字符串类型，`CHAR`和`VARCHAR`。

* `CHAR`是定长字符串，每个值所占用的空间是相同大小的。当我们存储具有相同长度的字符串(比如MD5值)时使用`CHAR`是不错的选择。值得注意的是，MySQL在存储`CHAR`值时，会删除所有末尾的空格，`CHAR`值也会根据需要采用末尾空格填充以方便比较。
* `VARCHAR`是变长字符串，其有1或2个额外字节记录字符串的长度。对于长度不一致的值使用`VARCHAR`是可以更节省空间的，因为它仅占用必要的空间。当然变长有一个坏处是，如果在`UPDATE`时，如果新值比原值更长，可能导致页内没有更多的空间可以存储行，就需要进行一些额外的工作，比如`InnoDB`会进行分裂页来使行可以放进页内。
* 有时使用`CHAR`来存储会经常更新的字符串，即使这些字符串长度并不一致。因为定长的`CHAR`更新性能更好，不容易产生碎片。
* 不要随便设置`VARCHAR`的长度。虽然`VARCHAR(5)`和`VARCHAR(200)`存储"hello"的空间开销是一样的，但使用`VARCHAR(5)`还是更有优势些。更长的列会消耗更多的内存，因为MySQL通常会分配固定大小的内存块来保存内部值。尤其是使用内存临时表进行操作时，这种优势会特别明显；在利用磁盘临时表进行排序时也会出现这种情况。所以最好还是只分配真正需要的空间。

#### BLOB和TEXT类型

`BLOB`和`TEXT`都是为了存储很大的数据而设计的串数据类型，分别用于存储二进行串和字符串。与其它类型不同，MySQL把每个`BLOB`和`TEXT`值当作一个独立的对象处理。存储引擎在存储时通常会做特殊处理。当`BLOB`和`TEXT`值太大时，InnoDB会使用专门的外部存储区来进行存储实际的值，此时每个值在行内需要1-4个字节存储一个指针。

MySQL对`BLOB`和`TEXT`列进行排序与其它类型是不同的。它只对每个列的最前`max_sort_length`元素而不是整个串做排序。MySQL不能将`BLOB`和`TEXT`列整个串进行索引，也不能使用这些索引消除排序。

因为Memory引擎不支持`BLOB`和`TEXT`类型，最好的解决方案避免使用`BLOB`和`TEXT`类型。如果实在无法避免，一般是在所用到的`BLOB`和`TEXT`字段的地方都使用`SUBSTRING(colum, length)`，将列值转换为字符串（在`ORDER BY`子句中也可以适用），这样就可以使用内存临时表了。但要确保截取的字符串足够短，不会使临时表的大小超过`max_heap_table_size`或`tmp_table_size`，超过以后MySQL会将内存临时表转换为MyISAM磁盘临时表。

#### 枚举(ENUM)

枚举列可以把一些不重复的字符串存储成一个预定义的集合。MySQL在内部会将每个值在列表中的位置保存为整数，并在表的`.frm`文件中保存"数字-字符串"的映射关系。这样，MySQL在存储枚举时是非常紧凑的，只需要1或2个字节。因为枚举其实是数字，所以对枚举的排序并不是按照定义的字符串进行排序的，而是按照定位枚举值时各值的位置。如果需要让其根据字符串进行排序，可以使用`FIELD()`函数，但这会导致MySQL无法利用索引消除排序。

如果需要改变枚举的可选值，则需要`ALTER TABLE`。但如果不是仅在末尾添加可选值，则会重建重建整个表来完成修改。

需要注意的要避免枚举和字符串进行关联，这种关联是比较慢的，因为必须要进行查找才能把枚举值转成字符串。不过枚举与枚举的关联则是很快的。

#### 日期和时间类型

MySQL有许多类型用来保存日期和时间。这里只谈谈两个很常用的类型：`DATETIME`和`TIMESTAMP`。

* `DATETIME`能保存很大的时间范围，从1001年到9999年，其精度为秒。它其实是用多个数字分别表达年月日时分秒，占用8个字节，并且与时区无关。
* `TIMESTAMP`保存的是从1970年1月1日0时0分0秒以来的秒数，和UNIX时间戳相同。它只占用4个字节，并且与时区有关。
* 通常建议使用`TIMESTAMP`表示时间，而不是`DATETIME`，因`TIMESTAMP`的空间效率更高。用`INT`来存储时间是没必要的，其和`TIMESTAMP`的性能一样，并且不方便处理，不推荐这样做。
* 如果需要更高精度的时间表示，比如精确到毫秒或纳秒，可以给`DATETIME`或`TIMESTAMP`显式指定长度，3表示精确到毫秒，6表示精确到纳秒。

#### 位数据类型(BIT)

`BIT`表示是二进制位串。它在不同的存储引擎下，有不同的空间开销。在MyISAM中，会打包所有的`BIT`列，然后使用最少的字节数来存储，比如`BIT(17)`需要占用3字节的空间。但在Memory和InnoDB中，会使用能够存储的最小整数类型来存放，这时`BIT(17)`需要占用4字节空间，相比使用整数表示并不能节省空间。

MySQL把`BIT`当做字符串类型，而不是数字类型。比如存储一个值为b'00111001'(十进制表示为57)，在检索时表示为字符串"9"(57的ASCII表示)，而不是数字57。这其实是反直觉的。我们应该慎用`BIT`，通常我们也能很好的避免它。

### 主键类型的选择

主键类型的选择是非常重要的。一般来说更有可能用主键与其它值进行比较(例如：在关联操作中)，或通过主键列寻找其他列。当选择主键类型时，不仅仅需要考虑存储的类型，还需要考虑MySQL对这种类型是怎么执行计算和比较的。一旦选定了一种类型，要确保在所有关键表中都使用同样的类型。类型之间要精确匹配，包括像`UNSIGNED`这样的属性。混用不同类型可能导致性能问题，或在比较操作时隐式类型转换导致的很难发现的错误。

* 整数类型通常是主键的最好选择，因为它们很快并且可以使用`AUTO_INCREMENT`。
* 如果可能，应该避免使用字符串作为主键，因为它们很消耗空间，并且通常比数字类型慢。
* 尤其要注意完全随机的字符串(例如：MD5，SHA1)。这种字符串会任意分布在很大的空间内，这会导致`INSERT`以及一些`SELECT`语句变得很慢:
  * 插入值会随机地写到索引不同位置，从而导致页分裂、磁盘随机访问，以及聚簇存储引擎产生聚簇索引碎片。
  * 逻辑上相邻的行会分布在磁盘和内存的不同地方，使得缓存赖以工作的访问局部性原理失败，从而导致缓存对所有类型的查询语句效果都很差。

### 范式与反范式

首先说明下数据库设计三大范式：

1. 必须不包含重复组的关系，即每一列都是不可拆分的原子项。
2. 关系模式必须满足第一范式，并且所有非主属性都完全依赖于主码，而不能只与主键的某一部分相关（主要针对联合主键而言）。
3. 关系模型满足第二范式，所有非主属性对任何候选关键字都不存在传递依赖，即每个属性都跟主键有直接关系而不是间接关系。

简单的来说，在范式化的数据库中，每个事实数据会出现并且只出现一次。相反，在反范式化的数据库中，信息会出现冗余。虽然我们一直强调数据库的范式，但并不是说范式就一定比反范式好，或者说一定要把数据库设计成完全范式化的。其实他们各有优缺点：

* 范式化的更新操作通常能比反范式化要快。因为范式化的数据只有很少或没有重复数据，所以只需要修改更少的数据。
* 范式化的表通常更小，可以更好地放在内存里，所以执行操作会更快。
* 范式化的数据很少有多余的数据，意味着更少需要`DISTINCT`或都`GROUP BY`语句来去除多佘的行。
* 反范式化的数据因为所以数据都在一张表中，可以很好的避免关联，在一些查询场景中会有更好的性能。

事实上，完全的范式化和完全的反范式化的数据库设计都是实验室才有的东西，在现实世界里很少会这么极端。我们需要根据自己的实际情况来混用范式化与反范式化，以达到最佳效果。

## 创建高性能索引

### MySQL中常用的索引类型

#### B-Tree索引

B-Tree索引是MySQL中用得最多的索引，如果没有指明索引类型，那多半指的是B-Tree索引。虽然不同的存储引擎的B-Tree索引使用的底层存储结构可能并不相同，但它们差不多都表示为树形结构，所有值都是按顺序存储的，并且每一个叶子页到根的距离相同。使用B-Tree索引的查找速度差不多是`O(log N)`级的。

B-Tree索引的使用范围(假设索引为`(name, age)`)：

* 全值匹配：和索引中的所有列进行匹配。如：`name='Jack' AND age=30`。
* 匹配最左前缀：只和索引的前面部分列进行匹配。如：`name='Jack'`。
* 匹配列前缀：只匹配某一列的值的开头部分。如：`name LIKE 'J%'`。
* 配置范围值：如：`name BETWEEN 'J' AND 'L'`。
* 精确匹配某一列，并且范围匹配另一列：如：`name='Jack' AND age BETWEEN 20 AND 40`。
* 在`ORDER BY`中使用，因为B-Tree索引是有序的。

B-Tree索引的使用限制(假设索引为`(first_name, last_name, age)`)：

* 如果不是按照索引的最左列开始查找，则无法使用索引。如：`last_name='Chen'`。
* 不能跳过索引中的列，这时只能使用前面部分的列进行索引。如：`first_name='Jack' AND age=30`，这里使用了`first_name`进行索引。
* 如果查询中有某个列的范围查询，则其右边的所有列都无法使用索引。如：`first_name='Jack' AND last_name LIKE 'C%' AND age=30`，这里没有使用`age`进行索引。

以上可以看出，当使用B-Tree索引时，索引列的顺序是非常重要的。在优化性能时，可能需要使用相同的列但顺序不同的索引来满足不同类型的查询需求。

#### 哈希索引

哈希索引是使用哈希表实现的。其查找速度很快，差不多是`O(1)`级的。但其有也很多限制，比如是无序的，并且只支持精确匹配。在MySQL中，只有Memory引擎显式支持哈希索引，哈希索引也是Memory引擎表的默认索引类型。

#### 全文索引

全文索引是一种特殊的索引类型，它查找的是文本中的关键词，而不是直接比较索引中的值。其原理差不多是通过分词器从文本中提取出一些关键词，再分别建立关键词到文本的索引，然后就可以很快的通过关键词找到这段文本了。在做文本检索时，全文索引是很好的选择。

### 高性能索引策略

#### 使用独立的列

独立的列指的是待索引的查询列不能是列表式的一部分，也不是函数的参数。如果查询中的列不是独立的，则MySQL不会使用些索引。例如：`WHERE age + 1 = 30`，这里Mysql是不会使用`age`索引的。

#### 索引列长度与索引选择性

有时需要为一个很长的字符串列创建索引，这会让索引变得大且慢。这时我们需要降低索引列的长度，有两个策略：

1. 添加一个这个字符串的Hash值列，使用这个Hash值列作为索引。如：`WHERE name_hash = CRC32('JACK') AND name = 'JACK'`。
2. 仅使用这个字符串的前部分作为索引。在添加索引时指明长度就可以实现。如：`ALTER TABLE user ADD KEY (name(4))`。

当降低索引列的长度，尤其是使用前部分作为索引这个策略时，我们需要注意索引的选择性。索引的选择性越强，也就是说索引能排除掉的非目标行越多，其查找性能就越高。为了得到既足够短，选择性还足够强的索引，我们可能需要在真实数据中做很多测试。

#### 去除冗余或重复与没用到的索引

索引不是没有代价的。索引需要占用空间，索引的维护也需要CPU开销。把没必要的索引及时清理掉是个好习惯。

#### 多列索引

有一个常见的使用索引的错误就是，为每个列创建独立的索引，或使用错误的顺序创建多列索引。根据自身的实际查询需求创建正确的顺序的多列索引往往能让索引的性能提升很多，甚至达到几个量级。因为多个索引往往并不能同时使用，而正确顺序的多列索引相比每个单列索引的选择性都要强得多。

#### 聚簇索引

聚簇索引并不是一种单独的索引类型，而一种数据存储方式。聚簇索引的顺序就是数据的物理存储顺序，因为数据的物理存储顺序只能有一个，所以聚簇索引也只有一个。当表有聚簇索引时，它的数据行实际上存放在索引的叶子页中。

InnoDB通过主键聚集数据，也就是说聚簇索引使用的列是主键列。如果没有定义主键，InnoDB会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB会隐式定义一个主键作为聚簇索引。

聚集的数据有一些重要的优点：

* 可以把相关数据保存在一起，这样只需要从磁盘读取少量的数据页就能获取整个相关信息。
* 数据访问更快。聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比非聚簇索引中查找更快
* 按主键取出一定范围数据的时候，使用用聚簇索引速度快，因为数据是有序存储的

使用聚簇索引需要注意的事项：

* 按主键顺序插入数据，如果不是，则最好在所有数据插入完成后使用`OPTIMIZE TABLE`重新组织一下表。因为随机顺序的插入导致大量的页分裂，会产生大量的聚簇索引碎片，占用更多的磁盘空间。
* 更新聚簇索引列的代价很高。因为被更新的行会移动到新的位置，其可能会导致页分裂，产生索引碎片。
* 聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。
* 二级索引保存的"行指针"的实质是主键值，而不是行的物理位置指针。这会导致二级索引的访问需要两次索引查找，而不是一次。

#### 覆盖索引

如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为"覆盖索引"。当发生覆盖索引时，MySQL会直接使用索引中的数据，而不必进行通过行指针查询数据行这个很可以导致随机IO的操作。所以说覆盖索引是非常有用的工具，可以极大地提高性能。

#### 使用索引扫描来做排序

B-Tree索引本身就是有序的，所以可以使用同一个索引，既用于查找行，又用于排序，这样可以节省排序的开销。只有当索引列顺序和`ORDER BY`子句顺序一致，并且所有列的排序方向都一样时，MySQL才能使用索引来对结果做排序。如果查询需要关联多张表，则只有当ORDER BY子名引用的字段全部为第一个表时，才能使用索引做排序。`ORDER BY`子句和查询时的限制是一样的：需要满足索引的最左前缀的要求。

## 查询性能优化

### 什么导致了慢查询

查询性能低下最基本的原因是访问的数据太多。大部分性能低下的查询都可以通过减少访问的数据量的方式进行优化。对于低效的查询，可以通过以下两个步骤来分析：

1. 确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时也可能是访问了太多的列。
2. 确认MySQL服务器层是否在分析大量超过需要的数据行。

### 重构查询

#### 一个复杂查询与多个简单查询

总有人强调需要在数据库层就尽可能完成多的工作，以尽可能的节省网络通信、查询解析和优化的开销。但这或许对MySQL并不适用，MySQL从设计上让连接与断开连接都很轻量级，在返回一个小的查询结果方面很高效。并且现在网络速度很快了，无论是带宽还是延迟上。所以运行多个小查询，现在不什么什么大问题了。没有必要写一个很复杂的查询，让MySQL做大量的工作，而这些工作放在客户端可能是轻而易举就完成了。当然，如果一个查询能够很容易胜任时还写成多个独立的查询也是不明智的。

#### 切分查询

有时需要对一个大查询分而治之，将大查询分成一些小查询，每个小查询的功能一样，只是只完成工作的一小部分。有一个很好的例子是清理过时数据。如果一次性就清理所有的过时数据，可能会一次锁往很多数据、占满整个事务日志、耗尽系统资源、阻塞很多少的但是重要的查询。这时我们可以通过`LIMIT`子句做一下切分，每次只清理一部分数据。这样可以大大降低对服务器的影响，还可以大大减少删除时锁的持有时间。

### 分解关联查询

有时可以将一个关联查询分解为多个单表查询，然后由客户端将这些查询结果组装到一起。乍一看好像没什么必要，还把事情复杂化了。但其实这样做还是有些优势的：

* 让缓存的效率更高。许多应用程序可以很方便地缓存单表查询的结果，这样让查询更多地使用缓存。再者，对MySQL的查询缓存来说，如果关联中的某个表发生了变化，那么就无法使用查询缓存了。而拆分后，如果某个表很少改变，那么基于该表的查询就可以重复利用查询缓存结果了。
* 将查询分解后，执行单个查询可以减少锁竞争。
* 在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展。
* 查询本身效率也可能会有所提升。使用`IN()`代替关联查询，可以让MySQL按照ID顺序进行查询，这可能比随机的关联要更高效。
* 可以减少冗余记录的查询，这可能会减少网络和内存的消耗。

总之，在不少场景下，分解关联查询会更高效，比如：当应用能够方便地缓存单表查询结果时、当可以将数据分布到不同的MySQL服务器上时、当能够使用`IN()`的方式代替关联查询时、当查询中使用同一个数据表时。

### MySQL查询优化器

MySQL的查询优化器是一个非常复杂的部件。它使用了很多优化策略来生成一个最优的执行计划。下面是一些MySQL能够处理的优化类型：

* 重新定义关联表的顺序
* 将外连接转化成内连接
* 使用等价变换规则来简化并规范表达式
* 优化`COUNT()`、`MIN()`和`MAX()`。比如可以使用一个变量来记录表中的行数量；取最小值只需取B-Tree索引最左端的记录；取最大值则只需要取B-Tree索引最右端的记录。
* 预估并转化为常数表达式。当MySQL检测到一个表达式可以转化为常数的时候，就会一直把该表达式作为常数进行优化处理。甚至一个查询也能够转化为一个常数。
* 覆盖索引扫描
* 子查询优化。在某些情况下可以将子查询转换成一种更高效的形式，从而减少多个查询多对次对数据进行访问。
* 提前终止查询。在发现已经满足查询需求的时候，MySQL总能立刻终止查询。
* 等值传播。如果两个列的值通过等式关联，那么MySQL能够把其中一个列的WHERE条件传递到另一列上。
* 列表`IN()`的比较。MySQL将`IN()`列表中的数据先进行排序，然后通过二分查询的方式来确定列表中的值是否满足条件。这是一个`O(log n)`的时间复杂度操作，等价的OR查询的复杂度是`O(n)`

由上可知，MySQL会帮我们做出很多优化工作，或许我们更多的是需要从更高的层级上对查询语句做出优化，而不是盯着细节不放。

## 后记

以上是一些提升MySQL性能的策略与技巧。当然，这不是全部，还有很多内容与细节上的东西这里没有提及。再者，提升性能也不是纸上谈兵的事，需要具体问题具体分析。然后，我们要学会使用`EXPLAN`，分析MySQL的执行过程，才能有的放矢。
{% endraw %}