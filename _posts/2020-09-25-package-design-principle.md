---
layout: post
title: "关于包设计原则"
subtitle: "优秀的代码组织与优秀的代码设计同样重要"
date: 2020-09-25 18:10:00
author: "Echcz"
header-style: "text"
catalog: true
tags:
  - "设计模式"
  - "代码组织"
---
{% raw %}
## 前言

随着软件规模和复杂度的增加，只靠类来组织代码就越来越难以应对，需要在更高层次对代码进行组织。类对于大型软件的代码组织来说粒度太细了，需要比类更大的东西来辅助大型软件的组织，这个东西就是包。但如何设计包，将类组织到包中呢？这是一个学问，和设计模式一样，经过大量实践，软件开发人员总结了6个包设计的原则。这些包设计原则为包设计提供了良好的指导与参考。

## 粒度:包的内聚性原则

###　重用发布等价原则(ERP)

> 重用的粒度就是发布的粒度

我们必须从潜在的重用者的角度去考虑包的内容。如果一个包的内容是用来重用的，那么他就不能再包含不是为了重用目的而设计的内容。可重用性不是唯一标准，我们还要考虑重用这些软件的人的需求。我们希望一个包中的所有类对于同一类用户来说都是可重用的，而不要包含一些对他来说完全无用的类。

### 共同重用原则(CRP)

> 一个包中的所有类应该是共同重用的，如果重用了包中的一个类，那么就要重用包中的所有类。

类很少会孤立的重用。一般来说，可重用的类需要与作为该可重用抽象一部分的其他类协作。CRP规定了这些类应该属于同一个包。在这样的包中，我们会看到类之间有很多依赖关系。这并是说CR不仅仅告诉我们哪些类应该放置进同一个包，CRP告诉我们更多的是，什么类不应该放在一起。CRP更有意义的是规定相互之间没有紧密联系的类不应该放在同一个包中。

### 共同封闭原则(CCP)

> 包中的所有类对于同一类性质的变化应该是共同封闭的。一个变化或对一个包产生影响，则将对该包中所有类产生影响，而对于其他的包不造成任何影响。

这是单一职责原则(SRP)在包设计中的应用。这条原则如SRP一样，规定了一个包不应该包含多个引起变化的原因。

在大多数应用中，可维护性的重要性是超过可重用性的。如果一个应用中的代码必须更改，那么我们宁愿这些更改都集中在一个包中。CCP鼓励我们把可能由于同样原因而更改的所有类共同聚集在同一个地方。这样当需求中的一个变化到来时，那个变化会限制在最小数量包中，从而减少软件的发布、重新验证、重新发行的工作量。

### 总结

在选择要共同组织到包中的类时，必须要考虑可重用性与可开发性之间的相反作用力。在这些作用力和应用的需要这间进行平衡不是一件简单的工作。此外，这个平衡几乎总是动态的。也就是说，今天看起来合适的划分到明年可能就不适用了。因此，当项目的重心从可开发性与重用性转变时，包的组织很可能会因此变动。

## 稳定性:包的耦合性原则

### 无环依赖原则(ADP)

> 在包的依赖关系图中，不允许存在环。

包的环形依赖会迫使在在依赖环中的包同时发布，并且当依赖环中的某一个包就必须依赖环中的所有包，实际上，他们就变成一个大包。此外，包的环形依赖会使得很难确定包的构建顺序，也许就不存在一个恰当的顺序。

解除依赖环主要有两个方法:

1. 使用依赖倒置原则(DIP)改变包之间的依赖方向
2. 新创建一个基础包，让原本相互依赖的包都依赖这个基础包

### 稳定依赖原则(SDP)

> 朝着稳定的方向进行依赖。

如果要使设计可维护，能响应需求变化，某种程度上的易变性就是必要的。我们可遵循共同封闭原则(CCP)，将变化隔离在易变的包之内，从而达到这个目标。但仅仅遵循共同封闭原则是不够的。对于任何包而言，其他人只要创建一个比它难以更改的包对它的依赖，就可以使它也变得难以更改。因此，我们还需要遵循稳定依赖原则(SDP)，确保那些打算易于更改的模块不会被那些比它们难以更改的模块所依赖。

首先，稳定性是什么？把一个硬币坚着放置到桌面，我们认为它是不稳的。因为只要用一点点力它就会改变这个状态。但如果没有干扰，它会一直保持这个状态。所以说稳定性和更改所需的工作量有关，而与变化的频率是无关。具有很多输入依赖关系(即被其它包依赖)的包是非常稳定的，因为要使所有依赖它的包能够相容于对它的更改，往往需要非常大的工作量。相反的，具有很多输出依赖关系(即依赖其它包)的包是不稳定的，因为输出依赖相当于是更改源，如果其依赖的包改了，此包也会被动的修改。

那么如何量化稳定性呢？

根据对稳定性的理解，稳定性与输入耦合度(Ca)成正比，与输出耦合度(Ce)成反比。其中:

* 输入耦合度(Afferent Coupling): 指处于该包的外部并依赖于该包内的类的类的数目
* 输出耦合度(Efferent Coupling): 指处于该包内部并依赖该包外的类的类的数目

可以如下定义不稳定性(I): `I = Ce / (Ca + Ce)`，这样不稳定性处于[0, 1]之间，当I=0时表示该包具有最大的稳定性，当I=1时表示该包具有最大的不稳定性。

系统中的高层架构和设计决策通常是稳定的，因此这些高层次的设计与决策往往只接收业务需求的更改，不应受技术细节的影响。所以应该把封闭系统高层设计的软件放进稳定的包中。然而如果把高层设计入进稳定的包，那么体现高层设计的源码就会难以更改，这会使设计变得不灵活。为了解决这个问题，可以使用OCP原则。OCP原则告诉我们足够灵活并且无需修改的类是存在的，即抽象类。

### 稳定抽象原则(SAP)

> 包的抽象程度应该和其稳定程度一致。

该原则把包的稳定性和抽象性联系起来。它规定，一个稳定的包应该也是抽象的，这样它的稳定性就不会使其无法扩展。另一方面，它规定，一个不稳定的包应该是具体的，因为它的不稳定性使得其内部的具体代码易于更改。SAP与SDP结合在一起，形成了针对包的DIP原则。

与量化稳定性一样，我们同样也能量化抽象性。包的抽象性与其中的抽象类数量成正比，与其中的具体类数量成反比。可以如下度量抽象性: `A = Na / Nc`。其中A是抽象性，Na是包中抽象类的数量，Nc是包中类的总数。

我们可以以不稳定性(I)为横坐标，抽象性(A)为纵坐标画图，从(0, 1)到(1, 0)的线被称为主序列，因为在这条线附近的包是符合SAP原则的。相反，最远离这条线的两个点(0, 0)和(1, 1)则是需要我们避免的。位于(0, 0)附近的地带，我们称之为痛苦地带，因为这些包又稳定，又无法扩展，僵化得无法更改修改。位于(1, 1)附近的地带，我们称之为无用地带，因为这些包抽象却又没有依赖者(即没人实现它)，这当然是无用的。

### 总结

经验表明，依赖关系是有好坏之分的，依赖与抽象结构模式应该相匹配。只有这样，我们才能让我们的设计如自然而然那般顺畅，而不至于陷入痛苦与无用中。
{% endraw %}