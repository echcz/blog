---
layout: post
title: "关于设计模式原则"
subtitle: "如果连设计模式的原则都不知道，你又怎么设计呢"
date: 2020-09-10 18:10:00
author: "Echcz"
header-style: "text"
catalog: true
tags:
  - "设计模式"
---
{% raw %}
## 前言

设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。不过在学习具体的设计模式之前，了解下设计模式原则是相当必要的，这些原则为具体的设计提供了高层次的指导与方法论参考。

## 五大设计模式原则(SOLID)

### 单一职责原则(SRP)

> 就一个类而言，应该仅有一个引起它变化的原因

首先要了解什么是职责。SRP把职责定义为"变化的原因"，即如果你能够想到多于一个动机去改变一个类，那么这个类就具有多于一个的职责。

职责如果一个类承担的职责过多，就等于把这些职责耦合在了一起。一个职责的变化可能削弱或抑制这个类完成其它职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会受到意想不到的破坏。

SRP是理解起来很简单的原则，但要正确运用却很难。我们总是很不经意间就把两个不同的职责结合到一起而不自知。软件设计真正要做的许多内容就是发现各个职责，并把这些职责分离。

### 开放封闭原则(OCP)

> 软件实体(类、模块、函数等等)应该是可以扩展的，但不可修改

如果程序中的一处改动就会产生连锁反应，导致一系列相关模块的改动，那么设计就具有僵化性的臭味。如果正确的应用OCP，那么需要对系统进行改动时只需要添加新代码而不必改动已经正常运行的代码。

想要成功运用OCP的关键是抽象，将稳定的的部分放在抽象类中，将频繁变化的部分放入实现类中。如果需要改动系统时只需要添加新的实现类，然后使用面向对象语言多态的特性就完了对系统的改动。

在许多方面，OCP都是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处(也就是灵活性、可重用性以及可维护性)。然而并且不说只要使用了面向对象的语言或技术就一定要100%遵循这个原则。要明白抽象是有代价的，对程序中的每个部分都肆意地进行抽象同样不是一个好主意。正确的做法是仅仅对当前程序中呈现出的频繁变化的部分进行抽象，可以让自己受一次愚弄，而不要随意预测变化。拒绝不成熟的抽象和抽象本身同样重要。

### 里氏替换原则(LSP)

> 子类型必须能够替换掉它们的基类型

LSP来源于芭芭拉.利斯科夫(Barbara Liskov)，她写道:

> 这里需要如下替换性质: 如若每个类型S的对象o1，都存在一个类型T的对象o2，使得在所有针对T编写的程序P中，用o1替换o2后，程序P的行为功能不变，则S是T的子类型。

关于LSP的重要性，想想违反该原则的后果就不言而喻了。对LSP的违反会导致程序的脆弱性，并且为了在违反LSP时程序仍能完成工作，需要让高层次代码去理解具体的派生类，这样会高层次代码对这些派生类就不是封闭的了，于是导致了对OCP的违反。

一个很经典的违反LSP的例子是矩形和正方形的例子。在数学的定义中，正方形是一种特殊的矩形，但如果把这个定义照搬到程序中就不是那么一回事了。因为我们在定义一个矩形时会预期改变矩形的高时不会对其宽产生影响，而正方形显然违背了这个预期。于是正方形在有些情况是不能代替的矩形的，如果把正方形定义为矩形的派生类就违反了LSP。从这个角度上看，IS-A的关系是关于行为的，只有当A能满足对B的行为预期时才能说A IS-A B，而不能仅仅从其表层的定义就可以说A IS-A B。

当然了，从另一方面来说，如果没有宽高互不影响这样的预期，让正方形定义为矩形的派生类是没有问题的。有效性并非本质属性。我们在考虑一个特定的设计是否恰当有效时，不能完全孤立地看这个解决方案。必须要根据该设计的使用者所做出的合理假设来审视它。和所有其它的原则一样，通常最好是仅仅只做对明显违反了LSP的情况做预测，直到出现相关的脆弱性的臭味才出处理它们。

LSP是使OCP成为可能的主要原则之一。正是子类型的可替换性才使得使用基类类型的模块可以在无需修改的情况下就能扩展。这种可替换性必须是开发人员可以隐式依赖的东西。如果没有显式地强制基类类型与其子类型的契约，那么代码就必须良好地、明显地表达出这一点。

### 接口隔离原则(ISP)

> 不应该强迫客户依赖于它们不用的方法

如果一个客户程序依赖于一个含有它不使用的方法的类，但其它客户程序却要使用该方法，那么当其他客户要求这个类改变时，就会影响到这个客户程序。我们希望尽可能地避免这种耦合，因此我们希望分离接口。

通过把胖类的接口分解为多个特定于客户程序的接口，可以实现让客户程序仅仅依赖它们实际调用方法的目标。每个特定于客户程序的接口仅仅声明它的特定客户调用的那些函数，接着该胖类就可以实现所有特定于客户程序的接口。这就解除了客户程序和它们没有调用的方法间的依赖关系，并使客户程序之间互不依赖。

有时我们会需要编写一个函数同时访问多个接口，而这些接口同时被一个胖类实现，这时会出现使用多参形式与单参形式的争论。使用单参形式的编写函数是很有诱惑力的，毕竟让一个对象多次出现在函数的参数列表中实在看起来有悖常理。但无论是否真的有悖常理，使用多参形式通常都应该优先于单参形式使用。单参形式迫使函数依赖胖类实现的每一个接口，这样当一个接口发生了改变，该函数及使用该函数的所有客户程序都会受到影响，这更有悖常理。此外，我们不能保证传入函数的多个参数都需要引用同一个对象。

### 依赖倒置原则(DIP)

> 1. 高层的模块不应该依赖低层模块，二者都应该依赖其抽象
> 2. 抽象不应该依赖细节，细节应该依赖抽象

这个原则在名字上就很让人疑惑，它怎么就倒置了？其实这是由于许多传统的软件开发方法(如结构化分析和设计)，总是倾向于创建一些高层模块依赖低层模块，策略依赖细节的软件结构。实际上这些方法的目的这一就是要定义子程序的层次结构，该层次结构描述了高层模块是是如何调用低层模块的。一个良好的面向对象的程序——如DIP定义的那样，其依赖程序的结构相对于传统的过程式的程序设计的通常结构而言就是"倒置"了。

考虑下当高层模块依赖低层模块时意味着什么。高层模块包含了一个应用程序中重要的策略选择是业务模型，正是这些高层模块才使得其所在的应用程序区别于其他程序。它们是与业务需求最接近的模块，业务需求的改变会第一时间传导到高层模块上，然后再传导在低层模块上。但如果这些高层模块依赖低层模块，这会让对低层模块的改变传导到高层模块上。此时就形成改变传导链接会形成一个环——业务需求->高层模块->低层模块->高层模块。这种改变传导环和模块间的循环依赖一样是非常荒谬的，这会让应对业务需求改变的工作变得无穿无尽且易于出错，让本来就复杂就程序变得更加复杂。

那么如何实现DIP呢?其实DIP的第2条说明就已经给出了答案。我们需要对低层模块中的细节进行抽象，形成抽象类，并在高层模块声明。这样让高层模块调用被其声明的抽象类，而在低层模块实现它们，就实现了倒置的依赖结构，即通过倒置接口所有权(即让客户拥有服务接口)来倒置依赖结构。

事实上，倒置的依赖结构正是面向对象设计与过程式设计的区别所在，也是面向对象设计的标志所在。使用何种语言来缩写程序是无关紧要的。如果程序的依赖关系是倒置的，它就是面向对象的设计。如果程序的依赖有关系不是倒置的，它就是过程化的设计。

DIP是实现许多面向对象技术所宣称的好处的基本低层机制。对DIP的正确应用对于创建可重用的框架来说也是必须的。同时DIP对于构建在变化面前富有弹性的代码也是非常重要的。

## 后记

在软件设计的实践中，总结了很多设计上的臭味。当软件出现了下面任何一种气味时，就表明软件正在腐化:

* 僵化性(Rigidity): 很难对系统进行改动，因为每个改动都会迫使许多对系统其他部分的其他改动。
* 脆弱性(Fragility): 对系统的改动会导致系统中和改动的地方在概念上无关的许多地方出现问题。
* 牢固性(Immobility): 很难解开系统的纠结，使之成为一些可在其他系统中重用的组件。
* 粘滞性(Viscosity): 做正确的事情比做错误的事情要困难。
* 不必要的复杂性(Needless Complexity): 设计中包含有不具任何直接好处的基础结构。
* 不必要的重复(Needless Repetition): 设计中包含有重复的结构，而该重复的结构本可以使用单一的抽象进行统一。
* 晦涩性(Opacity): 很难阅读、理解。没有很好地表现出意图。

以上软件设计模式原则是应对这些臭味的法宝。我们需要在软件设计中仔细分析业务需求，正确运用设计模式原则，认真设计程序结构才能消除这些臭味，构造出灵活、可重用、可维护的软件设计。
{% endraw %}