---
layout: post
title: "Go调度器概述"
subtitle: "goroutine实现原理"
date: 2020-10-26 15:09:00
author: "Echcz"
header-style: "text"
catalog: true
tags:
  - "Golang"
  - "协程"
---
{% raw %}
## 前言

说到Golang的优点，一个绕不开的话题就是其在语言层面实现了协程(gorutine)，能支持超大量的groutine数，并发性能高。但为什么呢？为什么Golang能支持超大量的groutine数呢，这不会导致线程频繁切换而产生过大的开销吗？

## 原理

## 线程模型

用户空间线程(协程)和内核空间线程之间的映射关系有：N:1，1:1和M:N：

* N:1：指多个用户线程始终在一个内核线程上跑。优点是上下文切换确实很快，但无法真正利用多核。
* 1:1：指一个用户线程就只有一个内核线程上跑。这样可以利用多核，但上下文切换很慢。
* M:N：指多个用户线程在多个内核线程上跑。这是可以兼具上面两种关系的优势的，但用户线程向内核线程的调度实现会变得复杂。

Go的用户线程和内核线程的关系就是M:N，其线程模型被称之为GPM调度模型。

### GPM模型

GPM分别代表的含义：

* G：指groutine，即用户线程(协程)。其包括了调用栈，重要的调度信息。
* P：指processor，代表调度上下文，可以把它看做一个局部调度器。它是实现M:N映射关系的关键。P的数量不能超过`GOMAXPROCS`环境变量值，这个值一般与CPU核心数相对应，其也代表了真正的并发度。
* M：指Machine，即内核线程，是真正干活的人。

GPM关系如图所示:
{% endraw %}
![GPM关系图]({{ site.baseurl }}/img/in-post/2020-10-26-go-scheduler_gpm.jpg)
{% raw %}
可以看到一个M拥有一个P，也有一个正在运行的G，然后P还有一个队列(runqueue)，保存了多个处理就绪状态的等待被调度运行的G。每当有一个go语句被执行(即创建一个待执行的goroutine)，runqueue就在其末尾加入一个G，在下一个调度点，就从runqueue中取出一个G执行。

看了上图后，你可能会问，为什么要维护P，P似乎可有可无？因为当线程被阻塞时，P可以放开此线程，转而投奔其它线程，以继续运行其他的G。我们来看一下当一个M被阻塞时的情况：
{% endraw %}
![GPM关系图]({{ site.baseurl }}/img/in-post/2020-10-26-go-scheduler_syscall.jpg)
{% raw %}
如图所示，当一个M0陷入阻塞时，P转而在M1上运行。调度器保证有足够的M来运行所有的P：图中的M1可能被创建，或从线程缓存中取出。

当M0返回时(即M0从被阻塞状态唤醒了)，它会尝试偷一个P来运行G。如果没有偷到的话，它就把G放在全局运行队列(global runqueue)里，然后自己就进入线程缓存里，因为G的运行需要P。

P会定期检索global runqueue的G，以便在自己消费掉自身runqueue里的G后有事可做。如果global runqueue里也没有G了，就会从其它P的runqueue里偷G。一般会偷一半走，这就确保了每个线程都能充分使用。

## 总结

Golang通过实现M:N线程模型，获取了多线程的好处的同时也尽量避免了线程上下文切换带来的开销。简化了高并发程序的复杂度。
{% endraw %}